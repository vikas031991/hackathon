{"remainingRequest":"/Users/vikas/Downloads/angularpwa/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/vikas/Downloads/angularpwa/node_modules/@angular/service-worker/esm5/service-worker.js","dependencies":[{"path":"/Users/vikas/Downloads/angularpwa/node_modules/@angular/service-worker/esm5/service-worker.js","mtime":1521065142000},{"path":"/Users/vikas/Downloads/angularpwa/node_modules/cache-loader/dist/cjs.js","mtime":1523856032056},{"path":"/Users/vikas/Downloads/angularpwa/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/**\n * @license Angular v5.2.9\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\nimport { isPlatformBrowser } from '@angular/common';\nimport { APP_INITIALIZER, ApplicationRef, Inject, Injectable, InjectionToken, Injector, NgModule, PLATFORM_ID } from '@angular/core';\nimport { filter } from 'rxjs/operator/filter';\nimport { take } from 'rxjs/operator/take';\nimport { toPromise } from 'rxjs/operator/toPromise';\nimport { __assign } from 'tslib';\nimport { concat } from 'rxjs/observable/concat';\nimport { defer } from 'rxjs/observable/defer';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { of } from 'rxjs/observable/of';\nimport { _throw } from 'rxjs/observable/throw';\nimport { _do } from 'rxjs/operator/do';\nimport { map } from 'rxjs/operator/map';\nimport { publish } from 'rxjs/operator/publish';\nimport { switchMap } from 'rxjs/operator/switchMap';\nimport { Subject } from 'rxjs/Subject';\nimport { merge } from 'rxjs/observable/merge';\nimport { never } from 'rxjs/observable/never';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERR_SW_NOT_SUPPORTED = 'Service workers are disabled or not supported by this browser';\n/**\n * @record\n */\n/**\n * \\@experimental\n * @record\n */\n/**\n * \\@experimental\n * @record\n */\n/**\n * @param {?} message\n * @return {?}\n */\nfunction errorObservable(message) {\n    return defer(function () { return _throw(new Error(message)); });\n}\n/**\n * \\@experimental\n */\nvar NgswCommChannel = /*@__PURE__*/ (function () {\n    function NgswCommChannel(serviceWorker, platformId) {\n        this.serviceWorker = serviceWorker;\n        if (!serviceWorker || !isPlatformBrowser(platformId)) {\n            this.serviceWorker = undefined;\n            this.worker = this.events = this.registration = errorObservable(ERR_SW_NOT_SUPPORTED);\n        }\n        else {\n            var /** @type {?} */ controllerChangeEvents = ((fromEvent(serviceWorker, 'controllerchange')));\n            var /** @type {?} */ controllerChanges = ((map.call(controllerChangeEvents, function () { return serviceWorker.controller; })));\n            var /** @type {?} */ currentController = ((defer(function () { return of(serviceWorker.controller); })));\n            var /** @type {?} */ controllerWithChanges = ((concat(currentController, controllerChanges)));\n            this.worker = /** @type {?} */ ((filter.call(controllerWithChanges, function (c) { return !!c; })));\n            this.registration = /** @type {?} */ ((switchMap.call(this.worker, function () { return serviceWorker.getRegistration(); })));\n            var /** @type {?} */ rawEvents = fromEvent(serviceWorker, 'message');\n            var /** @type {?} */ rawEventPayload = ((map.call(rawEvents, function (event) { return event.data; })));\n            var /** @type {?} */ eventsUnconnected = ((filter.call(rawEventPayload, function (event) { return !!event && !!((event))['type']; })));\n            var /** @type {?} */ events = ((publish.call(eventsUnconnected)));\n            this.events = events;\n            events.connect();\n        }\n    }\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} action\n     * @param {?} payload\n     * @return {?}\n     */\n    NgswCommChannel.prototype.postMessage = /**\n     * \\@internal\n     * @param {?} action\n     * @param {?} payload\n     * @return {?}\n     */\n        function (action, payload) {\n            var /** @type {?} */ worker = take.call(this.worker, 1);\n            var /** @type {?} */ sideEffect = _do.call(worker, function (sw) {\n                sw.postMessage(__assign({ action: action }, payload));\n            });\n            return /** @type {?} */ ((toPromise.call(sideEffect).then(function () { return undefined; })));\n        };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} type\n     * @param {?} payload\n     * @param {?} nonce\n     * @return {?}\n     */\n    NgswCommChannel.prototype.postMessageWithStatus = /**\n     * \\@internal\n     * @param {?} type\n     * @param {?} payload\n     * @param {?} nonce\n     * @return {?}\n     */\n        function (type, payload, nonce) {\n            var /** @type {?} */ waitForStatus = this.waitForStatus(nonce);\n            var /** @type {?} */ postMessage = this.postMessage(type, payload);\n            return Promise.all([waitForStatus, postMessage]).then(function () { return undefined; });\n        };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    NgswCommChannel.prototype.generateNonce = /**\n     * \\@internal\n     * @return {?}\n     */\n        function () { return Math.round(Math.random() * 10000000); };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @template T\n     * @param {?} type\n     * @return {?}\n     */\n    NgswCommChannel.prototype.eventsOfType = /**\n     * \\@internal\n     * @template T\n     * @param {?} type\n     * @return {?}\n     */\n        function (type) {\n            return /** @type {?} */ ((filter.call(this.events, function (event) { return event.type === type; })));\n        };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @template T\n     * @param {?} type\n     * @return {?}\n     */\n    NgswCommChannel.prototype.nextEventOfType = /**\n     * \\@internal\n     * @template T\n     * @param {?} type\n     * @return {?}\n     */\n        function (type) {\n            return /** @type {?} */ ((take.call(this.eventsOfType(type), 1)));\n        };\n    /**\n     * @internal\n     */\n    /**\n     * \\@internal\n     * @param {?} nonce\n     * @return {?}\n     */\n    NgswCommChannel.prototype.waitForStatus = /**\n     * \\@internal\n     * @param {?} nonce\n     * @return {?}\n     */\n        function (nonce) {\n            var /** @type {?} */ statusEventsWithNonce = ((filter.call(this.eventsOfType('STATUS'), function (event) { return event.nonce === nonce; })));\n            var /** @type {?} */ singleStatusEvent = ((take.call(statusEventsWithNonce, 1)));\n            var /** @type {?} */ mapErrorAndValue = ((map.call(singleStatusEvent, function (event) {\n                if (event.status) {\n                    return undefined;\n                }\n                throw new Error(/** @type {?} */ ((event.error)));\n            })));\n            return toPromise.call(mapErrorAndValue);\n        };\n    Object.defineProperty(NgswCommChannel.prototype, \"isEnabled\", {\n        get: /**\n         * @return {?}\n         */ function () { return !!this.serviceWorker; },\n        enumerable: true,\n        configurable: true\n    });\n    return NgswCommChannel;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Subscribe and listen to push notifications from the Service Worker.\n *\n * \\@experimental\n */\nvar SwPush = /*@__PURE__*/ (function () {\n    function SwPush(sw) {\n        this.sw = sw;\n        this.subscriptionChanges = new Subject();\n        if (!sw.isEnabled) {\n            this.messages = never();\n            this.subscription = never();\n            return;\n        }\n        this.messages =\n            map.call(this.sw.eventsOfType('PUSH'), function (message) { return message.data; });\n        this.pushManager = /** @type {?} */ ((map.call(this.sw.registration, function (registration) { return registration.pushManager; })));\n        var /** @type {?} */ workerDrivenSubscriptions = ((switchMap.call(this.pushManager, function (pm) { return pm.getSubscription().then(function (sub) { return sub; }); })));\n        this.subscription = merge(workerDrivenSubscriptions, this.subscriptionChanges);\n    }\n    Object.defineProperty(SwPush.prototype, \"isEnabled\", {\n        /**\n         * Returns true if the Service Worker is enabled (supported by the browser and enabled via\n         * ServiceWorkerModule).\n         */\n        get: /**\n         * Returns true if the Service Worker is enabled (supported by the browser and enabled via\n         * ServiceWorkerModule).\n         * @return {?}\n         */ function () { return this.sw.isEnabled; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    SwPush.prototype.requestSubscription = /**\n     * @param {?} options\n     * @return {?}\n     */\n        function (options) {\n            var _this = this;\n            if (!this.sw.isEnabled) {\n                return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n            }\n            var /** @type {?} */ pushOptions = { userVisibleOnly: true };\n            var /** @type {?} */ key = atob(options.serverPublicKey.replace(/_/g, '/').replace(/-/g, '+'));\n            var /** @type {?} */ applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));\n            for (var /** @type {?} */ i = 0; i < key.length; i++) {\n                applicationServerKey[i] = key.charCodeAt(i);\n            }\n            pushOptions.applicationServerKey = applicationServerKey;\n            var /** @type {?} */ subscribe = ((switchMap.call(this.pushManager, function (pm) { return pm.subscribe(pushOptions); })));\n            var /** @type {?} */ subscribeOnce = take.call(subscribe, 1);\n            return ((toPromise.call(subscribeOnce))).then(function (sub) {\n                _this.subscriptionChanges.next(sub);\n                return sub;\n            });\n        };\n    /**\n     * @return {?}\n     */\n    SwPush.prototype.unsubscribe = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this.sw.isEnabled) {\n                return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n            }\n            var /** @type {?} */ unsubscribe = switchMap.call(this.subscription, function (sub) {\n                if (sub !== null) {\n                    return sub.unsubscribe().then(function (success) {\n                        if (success) {\n                            _this.subscriptionChanges.next(null);\n                            return undefined;\n                        }\n                        else {\n                            throw new Error('Unsubscribe failed!');\n                        }\n                    });\n                }\n                else {\n                    throw new Error('Not subscribed to push notifications.');\n                }\n            });\n            var /** @type {?} */ unsubscribeOnce = take.call(unsubscribe, 1);\n            return /** @type {?} */ (toPromise.call(unsubscribeOnce));\n        };\n    return SwPush;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Subscribe to update notifications from the Service Worker, trigger update\n * checks, and forcibly activate updates.\n *\n * \\@experimental\n */\nvar SwUpdate = /*@__PURE__*/ (function () {\n    function SwUpdate(sw) {\n        this.sw = sw;\n        if (!sw.isEnabled) {\n            this.available = never();\n            this.activated = never();\n            return;\n        }\n        this.available = this.sw.eventsOfType('UPDATE_AVAILABLE');\n        this.activated = this.sw.eventsOfType('UPDATE_ACTIVATED');\n    }\n    Object.defineProperty(SwUpdate.prototype, \"isEnabled\", {\n        /**\n         * Returns true if the Service Worker is enabled (supported by the browser and enabled via\n         * ServiceWorkerModule).\n         */\n        get: /**\n         * Returns true if the Service Worker is enabled (supported by the browser and enabled via\n         * ServiceWorkerModule).\n         * @return {?}\n         */ function () { return this.sw.isEnabled; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SwUpdate.prototype.checkForUpdate = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.sw.isEnabled) {\n                return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n            }\n            var /** @type {?} */ statusNonce = this.sw.generateNonce();\n            return this.sw.postMessageWithStatus('CHECK_FOR_UPDATES', { statusNonce: statusNonce }, statusNonce);\n        };\n    /**\n     * @return {?}\n     */\n    SwUpdate.prototype.activateUpdate = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.sw.isEnabled) {\n                return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));\n            }\n            var /** @type {?} */ statusNonce = this.sw.generateNonce();\n            return this.sw.postMessageWithStatus('ACTIVATE_UPDATE', { statusNonce: statusNonce }, statusNonce);\n        };\n    return SwUpdate;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar RegistrationOptions = /*@__PURE__*/ (function () {\n    function RegistrationOptions() {\n    }\n    return RegistrationOptions;\n}());\nvar SCRIPT = new InjectionToken('NGSW_REGISTER_SCRIPT');\n/**\n * @param {?} injector\n * @param {?} script\n * @param {?} options\n * @param {?} platformId\n * @return {?}\n */\nfunction ngswAppInitializer(injector, script, options, platformId) {\n    var /** @type {?} */ initializer = function () {\n        var /** @type {?} */ app = injector.get(ApplicationRef);\n        if (!(isPlatformBrowser(platformId) && ('serviceWorker' in navigator) &&\n            options.enabled !== false)) {\n            return;\n        }\n        var /** @type {?} */ onStable = (filter.call(app.isStable, function (stable) { return !!stable; }));\n        var /** @type {?} */ isStable = (take.call(onStable, 1));\n        var /** @type {?} */ whenStable = (toPromise.call(isStable));\n        // Wait for service worker controller changes, and fire an INITIALIZE action when a new SW\n        // becomes active. This allows the SW to initialize itself even if there is no application\n        // traffic.\n        navigator.serviceWorker.addEventListener('controllerchange', function () {\n            if (navigator.serviceWorker.controller !== null) {\n                navigator.serviceWorker.controller.postMessage({ action: 'INITIALIZE' });\n            }\n        });\n        // Don't return the Promise, as that will block the application until the SW is registered, and\n        // cause a crash if the SW registration fails.\n        whenStable.then(function () { return navigator.serviceWorker.register(script, { scope: options.scope }); });\n    };\n    return initializer;\n}\n/**\n * @param {?} opts\n * @param {?} platformId\n * @return {?}\n */\nfunction ngswCommChannelFactory(opts, platformId) {\n    return new NgswCommChannel(opts.enabled !== false ? navigator.serviceWorker : undefined, platformId);\n}\n/**\n * \\@experimental\n */\nvar ServiceWorkerModule = /*@__PURE__*/ (function () {\n    function ServiceWorkerModule() {\n    }\n    /**\n     * Register the given Angular Service Worker script.\n     *\n     * If `enabled` is set to `false` in the given options, the module will behave as if service\n     * workers are not supported by the browser, and the service worker will not be registered.\n     */\n    /**\n     * Register the given Angular Service Worker script.\n     *\n     * If `enabled` is set to `false` in the given options, the module will behave as if service\n     * workers are not supported by the browser, and the service worker will not be registered.\n     * @param {?} script\n     * @param {?=} opts\n     * @return {?}\n     */\n    ServiceWorkerModule.register = /**\n     * Register the given Angular Service Worker script.\n     *\n     * If `enabled` is set to `false` in the given options, the module will behave as if service\n     * workers are not supported by the browser, and the service worker will not be registered.\n     * @param {?} script\n     * @param {?=} opts\n     * @return {?}\n     */\n        function (script, opts) {\n            if (opts === void 0) {\n                opts = {};\n            }\n            return {\n                ngModule: ServiceWorkerModule,\n                providers: [\n                    { provide: SCRIPT, useValue: script },\n                    { provide: RegistrationOptions, useValue: opts },\n                    {\n                        provide: NgswCommChannel,\n                        useFactory: ngswCommChannelFactory,\n                        deps: [RegistrationOptions, PLATFORM_ID]\n                    },\n                    {\n                        provide: APP_INITIALIZER,\n                        useFactory: ngswAppInitializer,\n                        deps: [Injector, SCRIPT, RegistrationOptions, PLATFORM_ID],\n                        multi: true,\n                    },\n                ],\n            };\n        };\n    return ServiceWorkerModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { ServiceWorkerModule, SwPush, SwUpdate, NgswCommChannel as ɵe, RegistrationOptions as ɵa, SCRIPT as ɵb, ngswAppInitializer as ɵc, ngswCommChannelFactory as ɵd };\n//# sourceMappingURL=service-worker.js.map\n",null]}